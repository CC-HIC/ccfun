#'  @export
gen_alveolar_gradient <- function(dt, input, pao2, paco2, pfratio = TRUE, percentage = T, units = "kpa", output = NULL) {
#  =========================================================
#  =   APACHE - Generator of alveolar gradient Variable    =
#  =========================================================
# appending _ to var names for readability and to ensure uses scoped version
# requires - fio2, paO2 and paCO2 variables
# Non-standard evaluation
pars <- as.list(match.call()[-1])
pars$pao2 <- pao2
pars$paco2 <- paco2
pars$input <- input
# Set to NA by default (numeric)
if(is.null(output)) {
output <- "Grad"
}
if (is.factor(dt[,get(paco2)])) {
dt[, `:=`(dummy_variable = suppressWarnings(as.numeric(as.character(get(paco2)))))]
dt[, paco2 :=  dummy_variable, with = F]
dt[, dummy_variable := NULL]
}
if (is.factor(dt[,get(pao2)])) {
dt[, `:=`(dummy_variable = suppressWarnings(as.numeric(as.character(get(pao2)))))]
dt[, pao2 :=  dummy_variable, with = F]
dt[, dummy_variable := NULL]
}
if (is.factor(dt[,get(input)])) {
dt[, `:=`(dummy_variable = suppressWarnings(as.numeric(as.character(get(input)))))]
dt[, input :=  dummy_variable, with = F]
dt[, dummy_variable := NULL]
}
dt[, (output) := suppressWarnings(as.numeric(NA))]
# Build Comorbidity variable:
# The fio2 is expressed as a ratio, and extracted from the pao2 on fio2 ratio. PaO2 is expressed in kpa.
if (pfratio == T && units == "kpa" && percentage == F){
dt[, (output) := ((100 - 6.2) * get(pao2) * 7.500615)]
dt[, (output) := get(output) / get(input)]
dt[, (output) := get(output) - get(pao2)- get(paco2)]
}
# The fio2 is expressed as a ratio, and extracted from the pao2 on fio2 ratio. PaO2 is expressed in mmHg.
if (pfratio == T && units == "mmHg" && percentage == F){
dt[, (output) := ((760 - 47) * get(pao2))]
dt[, (output) := get(output) / get(input)]
dt[, (output) := get(output) - get(pao2)- get(paco2)]
}
# The fio2 is expressed as a ratio PaO2 is expressed in kpa.
if (pfratio == F && units == "kpa" && percentage == F){
dt[, (output) := ((100 - 6.2) * get(input) - (get(pao2)- get(paco2)))]
}
# The fio2 is expressed as a ratio PaO2 is expressed in mmHg.
if (pfratio == F && units == "mmHg" && percentage == F){
dt[, (output) := ((760 - 47) * get(input)- get(pao2)- get(paco2))]
}
# The fio2 is expressed as a percentage, and extracted from the pao2 on fio2 ratio. PaO2 is expressed in kpa.
if (pfratio == T && units == "kpa" && percentage == T){
dt[, (output) := ((100 - 6.2) * get(pao2) * 7.500615)]
dt[, (output) := get(output) / get(input)]
dt[, (output) := get(output) - get(pao2)- get(paco2)]
}
# The fio2 is expressed as a percentage, and extracted from the pao2 on fio2 ratio. PaO2 is expressed in mmHg.
if (pfratio == T && units == "mmHg" && percentage == T){
dt[, (output) := ((760 - 47) * get(pao2))]
dt[, (output) := get(output) / get(input)]
dt[, (output) := get(output) - get(pao2)- get(paco2)]
}
# The fio2 is expressed as a percentage. PaO2 is expressed in mmHg.
if (pfratio == F && units == "kpa" && percentage == T){
dt[, (output) := ((100 - 6.2) * get(input)*0.01 - (get(pao2)- get(paco2)))]
}
# The fio2 is expressed as a percentage. PaO2 is expressed in kpa.
if (pfratio == F && units == "mmHg" && percentage == T){
dt[, (output) := ((760 - 47) * get(input)*0.01 - get(pao2) - get(paco2))]
}
}
#' @title Generates the APACHE Glasgow Coma Scale score
#'
#' @description
#' Generates the APACHE gcs score;
#'
#' @import data.table
#' @param dt data.table containing physiology data
#' @param output Column Name for the result of computation
#' @param input a vector of numeric data
#'
#'  @export
gen_apache_gcs <- function(dt, input, output = NULL) {
#  ===============================
#  = APACHE - Glasgow Coma Scale =
#  ===============================
# appending _ to var gcsmes for readability and to ensure uses scoped version
# requires known or unknown chronic kidney disease status
# Need to know the status  of sedation
# library(data.table)
# data.table changes the object in place unless you use dt1 <- copy(dt)
# so passing data.tables via function is actually just passing a reference
# Non-standard evaluation
pars <- as.list(match.call()[-1])
pars$input <- input
# Set to gcs by default (numeric)
if(is.null(output)) {
output <- "apache_gcs"
}
dt[, (output) := suppressWarnings(as.numeric(NA))]
# Set mf variable as numeric
if (is.factor(dt[,get(input)])) {
dt[, `:=`(dummy_variable = suppressWarnings(as.numeric(as.character(get(input)))))]
dt[, (input) :=  dummy_variable, with = F]
dt[, dummy_variable := NULL]
}
# Define conditions via dummy vars
# Update based on conditions
# Order of conditions is IMPORTANT
# APACHE = 15- GCS
dt[,   (output) := round(15 - get(input),0)]
dt[get(output) > 12, (output) := 12]
}
#' @title Generates the APACHE Acute Kidney Injury score
#'
#' @description
#' Generates the APACHE aki score;
#'
#' @import data.table
#' @param dt data.table containing physiology data
#' @param output Column Name for the result of computation
#' @param input a vector of numeric data
#' @param with_ckd a logical vector, preexisting chronic renal function impairement
#'
#'  @export
gen_apache_aki <- function(dt, input, crrt, output = NULL) {
#  ================================
#  = APACHE - Acute Kidney Injury =
#  ================================
# appending _ to var akimes for readability and to ensure uses scoped version
# requires known or unknown chronic kidney disease status
# library(data.table)
# data.table changes the object in place unless you use dt1 <- copy(dt)
# so passing data.tables via function is actually just passing a reference
# Non-standard evaluation
pars <- as.list(match.call()[-1])
pars$input <- input
pars$crrt <- crrt
# Set to aki by default (numeric)
if(is.null(output)) {
output <- "apache_aki"
}
dt[, (output) := suppressWarnings(as.numeric(NA))]
# Set mf variable as numeric
if (is.factor(dt[,get(input)])) {
dt[, `:=`(dummy_variable = suppressWarnings(as.numeric(as.character(get(input)))))]
dt[, (input) :=  dummy_variable, with = F]
dt[, dummy_variable := NULL]
}
# Define conditions via dummy vars
# Update based on conditions
# Order of conditions is IMPORTANT
# APACHE = 0
dt[(get(input) > c(54)), (output) := 0]
# APACHE = 1
dt[(get(input) < c(55)) | (get(input) > c(129)), (output) := 1]
# APACHE = 2
dt[(get(input) > c(169)), (output) := 2]
# APACHE = 3
dt[(get(input) > c(5.9)), (output) := 3]
# APACHE = 4
dt[(get(input) > c(304)), (output) := 4]
# crrt
dt[get(crrt) < 1, (output) := get(output)*2]
}
#' @title Generates the APACHE Arterial Pressure score
#'
#' @description
#' Generates the APACHE Arterial Pressure score;
#'
#' @import data.table
#' @param dt data.table containing physiology data
#' @param input Arterial Pressure
#' @param output Column name for the result of computation
#'
#' @examples
#' # system.time(gen_apache_map(ddata, temp_ = map))
#' # table(ddata$apache_map, useNA="always")
#' # ddata[map > 40][sample(nrow(ddata[map > 40]),20), .(map)]
#'  @export
gen_apache_map <- function(dt, input, output = NULL) {
#  ==============================
#  = APACHE - Arterial Pressure =
#  ==============================
# appending _ to var names for readability and to ensure uses scoped version
# library(data.table)
# data.table changes the object in place unless you use dt1 <- copy(dt)
# so passing data.tables via function is actually just passing a reference
# Non-standard evaluation
pars <- as.list(match.call()[-1])
pars$input <- input
# Set to NA by default (numeric)
if(is.null(output)) {
output <- "apache_map"
}
#dt[, (output) := suppressWarnings(as.numeric(NA))]
# Set rr_ variable as numeric
if (is.factor(dt[,get(input)])) {
dt[, `:=`(dummy_variable = suppressWarnings(as.numeric(as.character(get(input)))))]
dt[, input :=  dummy_variable, with = F]
dt[, dummy_variable := NULL]
}
# Define conditions via dummy vars
# Update based on conditions
# Order of conditions is IMPORTANT
# APACHE = 0
dt[get(input) %between% c(70,109), (output) := 0]
# APACHE = 2
dt[(get(input) %between% c(50,69)) | (get(input) %between% c(110,129)), (output) := 2]
# APACHE = 3
dt[get(input) %between% c(130,159), (output) := 3]
# APACHE = 4
dt[(get(input) < c(50)) | (get(input) > c(159)), (output) := 4]
}
#' @title Generates the APACHE Heart Rate score
#'
#' @description
#' Generates the APACHE Heart Rate score;
#'
#' @import data.table
#' @param dt data.table containing physiology data
#' @param input Heart Rate
#' @param output Column name for the result of computation
#'
#' @examples
#' # system.time(gen_apache_hr(ddata, hr = HR))
#' # table(ddata$apache_hr, useNA="always")
#' # ddata[hr > 40][sample(nrow(ddata[hr > 40]),20), .(hr)]
#'  @export
gen_apache_hr <- function(dt, input, output = NULL) {
#  =============================
#  = APACHE - Heart Rate =
#  =============================
# appending _ to var names for readability and to ensure uses scoped version
# library(data.table)
# data.table changes the object in place unless you use dt1 <- copy(dt)
# so passing data.tables via function is actually just passing a reference
# Non-standard evaluation
pars <- as.list(match.call()[-1])
pars$input <- input
# Set to NA by default (numeric)
if(is.null(output)) {
output <- "apache_hr"
}
dt[, (output) := suppressWarnings(as.numeric(NA))]
# Set rr_ variable as numeric
if (is.factor(dt[,get(input)])) {
dt[, `:=`(dummy_variable = suppressWarnings(as.numeric(as.character(get(input)))))]
dt[, input :=  dummy_variable, with = F]
dt[, dummy_variable := NULL]
}
# Define conditions via dummy vars
# Update based on conditions
# Order of conditions is IMPORTANT
# APACHE = 0
dt[get(input) %between% c(70,109), (output) := 0]
# APACHE = 2
dt[(get(input) %between% c(55,69)) | (get(input) %between% c(110,139)), (output) := 2]
# APACHE = 3
dt[(get(input) %between% c(40,54)) | (get(input) %between% c(140,179)), (output) := 3]
# APACHE = 4
dt[(get(input) < c(40)) | (get(input) > c(179)), (output) := 4]
}
#' @title Generates the APACHE Hematocrit score
#'
#' @description
#' Generates the APACHE ht score;
#'
#' @import data.table
#' @param dt data.table containing physiology data
#' @param output Column Name for the result of computation
#' @param input a vector of numeric data
#'
#'  @export
gen_apache_ht <- function(dt, input, haemoglobin = TRUE, vgm = 0.3,  output = NULL) {
#  =======================
#  = APACHE - Hematocrit =
#  =======================
# appending _ to var htmes for readability and to ensure uses scoped version
# requires known or unknown chronic kidney disease status
# library(data.table)
# data.table changes the object in place unless you use dt1 <- copy(dt)
# so passing data.tables via function is actually just passing a reference
# Non-standard evaluation
pars <- as.list(match.call()[-1])
pars$input <- input
# Set to ht by default (numeric)
if(is.null(output)) {
output <- "apache_ht"
}
dt[, (output) := suppressWarnings(as.numeric(NA))]
# Set mf variable as numeric
if (is.factor(dt[,get(input)])) {
dt[, `:=`(dummy_variable = suppressWarnings(as.numeric(as.character(get(input)))))]
dt[, (input) :=  dummy_variable, with = F]
dt[, dummy_variable := NULL]
}
# Define conditions via dummy vars
# Update based on conditions
# Order of conditions is IMPORTANT
# APACHE = 0
if(haemoglobin == T){
dt[(get(input) > c(29/vgm)), (output) := 0]
}else{
dt[(get(input) > c(29)), (output) := 0]
}
# APACHE = 1
if(haemoglobin == T){
dt[(get(input) > c(45.9/vgm)), (output) := 1]
}else{
dt[(get(input) > c(45.9)), (output) := 1]
}
# APACHE = 2
if(haemoglobin == T){
dt[(get(input) < c(30/vgm)) | (get(input) > c(49.9/vgm)), (output) := 2]
}else{
dt[(get(input) < c(30)) | (get(input) > c(49.9)), (output) := 2]
}
# APACHE = 4
if(haemoglobin == T){
dt[(get(input) < c(20/vgm)) | (get(input) > c(59.9/vgm)), (output) := 4]
}else{
dt[(get(input) < c(20)) | (get(input) > c(59.9)), (output) := 4]
}
}
#' @title Generates the APACHE Potassium score
#'
#' @description
#' Generates the APACHE Potassium score;
#'
#' @import data.table
#' @param dt data.table containing physiology data
#' @param output Column Kme for the result of computation
#' @param input a vector of numeric data
#'
#'  @export
gen_apache_K <- function(dt, input, output = NULL) {
#  ======================
#  = APACHE - Potassium =
#  ======================
# appending _ to var Kmes for readability and to ensure uses scoped version
# requires Potassium concentration [K] in mmol/l
# library(data.table)
# data.table changes the object in place unless you use dt1 <- copy(dt)
# so passing data.tables via function is actually just passing a reference
# Non-standard evaluation
pars <- as.list(match.call()[-1])
pars$input <- input
# Set to K by default (numeric)
if(is.null(output)) {
output <- "apache_K"
}
dt[, (output) := suppressWarnings(as.numeric(NA))]
# Set mf variable as numeric
if (is.factor(dt[,get(input)])) {
dt[, `:=`(dummy_variable = suppressWarnings(as.numeric(as.character(get(input)))))]
dt[, (input) :=  dummy_variable, with = F]
dt[, dummy_variable := NULL]
}
# Define conditions via dummy vars
# Update based on conditions
# Order of conditions is IMPORTANT
# APACHE = 0
dt[(get(input) > c(3.4)), (output) := 0]
# APACHE = 1
dt[(get(input) > c(2.9)), (output) := 1]
# APACHE = 2
dt[(get(input) < c(3))  | (get(input) > c(5.4)), (output) := 2]
# APACHE = 3
dt[(get(input) > c(5.9)), (output) := 3]
# APACHE = 4
dt[(get(input) < c(2.5))  | (get(input) > c(6.9)), (output) := 4]
}
source('G:/UCLH/ccfun/R/gen_apache_mf.R')
source('G:/UCLH/ccfun/R/gen_apache_Na.R')
source('G:/UCLH/ccfun/R/gen_apache_rf.R')
source('G:/UCLH/ccfun/R/gen_apache_rr.R')
source('G:/UCLH/ccfun/R/gen_apache_temp.R')
source('G:/UCLH/ccfun/R/gen_apache_wbc.R')
source('G:/UCLH/ccfun/R/gen_alveolar_gradient.R')
source('G:/UCLH/ccfun/R/gen_apache_chronic.R')
data <- gen_comorbidity(dt = data, input = Comorbidities)
#' @title Generates the APACHE Admission Type score
source('G:/UCLH/ccfun/R/gen_comorbidity.R')
names(data)
data[, Biopsy proven cirrhosis]
data[,.N, by = `Biopsy proven cirrhosis`]
data <- gen_comorbidity(dt = data, input = Comorbidities)
data[,.N, by = `Comorbidity`]
Comorbidities
1 + NA
output<- "Comorbidity"
output
data[, .N, by = output]
data[, output := 0]
data
data[, (output) := 0]
data[, .N, by = output]
Variables$hco3
source('G:/UCLH/ccfun/R/gen_comorbidity.R')
data <- gen_comorbidity(dt = data, input = Variables)
data <- gen_comorbidity(dt = data, input = Comorbidities)
source('G:/UCLH/ccfun/R/gen_comorbidity.R')
data <- gen_comorbidity(dt = data, input = Comorbidities)
cOMORBIDITIES
Comorbidities
data <- gen_comorbidity(dt = data, input = Comorbidities)
source('G:/UCLH/ccfun/R/gen_comorbidity.R')
data <- gen_comorbidity(dt = data, input = Comorbidities)
dt <- data
output <- "Comorbidity"
dt[, (output) := 0]
for (i in 1:length(input)){
dt[get(input[[i]])    %in% "1",(output) := (output) + 1]
}
input <- "Comorbidities"
for (i in 1:length(input)){
dt[get(input[[i]])    %in% "1",(output) := (output) + 1]
}
dt[get(output) > 0, (output) := 1]
output
for (i in 1:length(input)){
dt[is.na(get(input[[i]])), (output) := NA]
}
dt[get(output) > 0, (output) := 1]
dt[output > 0, (output) := 1]
dt
dt[Comorbidity > 0, (output) := 1]
dt
source('G:/UCLH/ccfun/R/gen_comorbidity.R')
data <- gen_comorbidity(dt = data, input = Comorbidities)
data
data
data[, output := NA]
data
data[, output := NULL]
data
data[, .N, by = Comorbidity]
data <- gen_comorbidity(dt = data, input = Comorbidities)
source('G:/UCLH/ccfun/R/gen_comorbidity.R')
data <- gen_comorbidity(dt = data, input = Comorbidities)
data
data
data[, .N, by = Comorbidity]
source('G:/UCLH/ccfun/R/gen_comorbidity.R')
data <- gen_comorbidity(dt = data, input = Comorbidities)
data[, .N, by = Comorbidity]
source('G:/UCLH/ccfun/R/gen_apache_chronic.R')
data <- gen_apache_chronic(dt = data, admission = Variables$admission, surgery = Variables$surgery,
Comorbidity = Variables$Comorbidity, output = NULL)
data
data
data[,.N, by = apache_chronic]
rm(list= ls())
gc()
library(ccdata)
library(ccfun)
library(apacher)
library(assertthat)
wdbackup <- getwd()
# Defining the Path to Find the Yaml file
DictionaryPath <- "G:/UCLH/paper-brc/data/"
Dictionary <- "ANALYSIS_APACHE.yaml"
# Defining the Path to Find the Data Environment
DataPath <- "G:/UCLH/paper-brc/data/"
DataName <- "delta_num.Rdata"
# Naming the Datatable
data <- "dt"
# Renaming column of the DataTable
Renaming <- "yes"
ColInput <- "NHICcode"
ColOutput <- "dataItem"
if (!exists("ccd_delta_num")){
load(paste(DataPath,DataName, sep = ""))
}
# Creating the DataTable
data <- create2dclean(ccd_delta_num, paste(DictionaryPath,Dictionary, sep = ""), nchunks=5)
# Free memory space
rm(ccd_delta_num)
gc()
#
DictionaryPath
DataPath
data <- create2dclean(ccd_delta_num, paste(DictionaryPath,Dictionary, sep = ""), nchunks=5)
if (!exists("ccd_delta_num")){
load(paste(DataPath,DataName, sep = ""))
}
?match.call
data <- create2dclean(ccd_delta_num, paste(DictionaryPath,Dictionary, sep = ""), nchunks=5)
library(ccdata)
DictionaryPath
Dictionary
paste(DictionaryPath,Dictionary, sep = "")
list.files(DictionaryPath)
data <- create2dclean(ccd_delta_num, paste(DictionaryPath,Dictionary, sep = ""), nchunks=5)
warnings()
data(xx, envir=parent.env(environment()))
reload()
ccdata:::xx
install_github(
"UCL-HIC/ccdata",
ref="master",   # - [ ] NOTE(2016-06-03): use master branch by default
auth_token="b0d9ea882d45faed268bbec4df3f5c150d082949") # PAT token
library(devtools)
data <- create2dclean(ccd_delta_num, paste(DictionaryPath,Dictionary, sep = ""), nchunks=5)
library("ccdata", lib.loc="~/R/win-library/3.3")
library("ccfun", lib.loc="~/R/win-library/3.3")
library("devtools", lib.loc="~/R/win-library/3.3")
data <- create2dclean(ccd_delta_num, paste(DictionaryPath,Dictionary, sep = ""), nchunks=5)
