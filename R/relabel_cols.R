#' @title Relabels a wide data2d data.table
#'
#' @description
#' Relabels the columns of a wide data2d data.table (as generated by
#' the selectTable function in ccdata). Because this uses the
#' data.table::setnames function then the name changes happen 'in place'
#' and nothing is returned
#'
#' @import data.table
#' @param dt data.table to be relabelled
#' @param dict defaults to ITEM_REF
#' @param label.in name for the item to be translated
#' @param label.out name of the item to be used for the new column name
#' @return 0 (if the function completes)
#'
#' @examples
#' # use the ITEM_REF dictionary (not run)
#' # relabel_cols(tdt, "dataItem", "shortName")
#' # use a custom dictionary (not run)
#' # relabel_cols(tdt, "dataItem", "shortName", dict=analysis.dict)

#' @export
relabel_cols <- function(dt, label.in, label.out, dict=NULL) {
  # library(purrr)
  # If no dictionary passed then use ITEM_REF.yaml
  if (is.null(dict)) {
    # Checks the ccdata package has loaded the ccdata.env
    # This will be used to relabel the columns
    warning(exists("ccdata.env"))
    path <- system.file("conf/ITEM_REF.yaml", package = "ccdata")
    assertthat::assert_that(file.exists(path))
    ccdata.dict <- yaml::yaml.load_file(path)
    # If using ITEM_REF.yaml then only the following labels are valid
    # label.in <- "dataItem"
    # label.out <- "NHICcode"
    stopifnot(all(c(label.in, label.out) %in% c("dataItem", "NHICcode", "shortName")))
    # dict <- ccdata.env$ITEM_REF
    dict <- ccdata.dict
  }
  else {
    # Make sure dictionary is a list
    stopifnot(is.list(dict))
    # - [ ] TODO(2016-05-12): check that label.in and label.out are items in sublists
  }

  # Check NHICcode in dictionary if needed
  if ("NHICcode" == label.in | "NHICcode" == label.out) {
    if (0==length(names(Filter(function(y) (!is.null(y)),
          purrr::map(dict, "NHICcode"))))
        ) {
      fields <- names(dict)
      for (i in 1:length(fields)) {
          dict[[fields[i]]]$NHICcode <- fields[i]
      }
    }
  }

  # Depends on data.table setnames function
  stopifnot("data.table" %in% class(dt))

  # Loop through names
  names.old <- names(dt)
  # check column names are unique and stop if not
  stopifnot(length(unique(names.old)) == length(names.old))
  # print(names.old)
  names.new <- vector(mode="character")
  # print(names.new)

  for (i in 1:length(names.old)) {
    # now get NHIC code from ccdata.env$ITEM_REF
    # print(dict_translate(dict, names.old[i], label.in, label.out))
    names.new[i] <- (dict_translate(dict, names.old[i], label.in, label.out))
    # update name if found
    if (!is.na(names.new[i])) {
      writeLines(paste0("... Translating: ", names.old[i], " to: ", names.new[i]))
      setnames(dt, names.old[i], names.new[i])
    } else {
      writeLines(paste0("NOT translating: ", names.old[i]))

    }
  }
  # print(data.table(names.old = names.old, names.new = names.new))
  # print(names(dt))
  # - [ ] NOTE(2016-05-12): nothing to return because setnames operates on the data.table passed?
  return(0)
}


# Helper function
dict_translate <- function(dict, value.a, label.in, label.out) {
    # Given a list of lists with subitems named label.in and label.out
    # then return the value in label.out given value in label.in
    # Look up the index
    X <- purrr::map(dict, label.in)
    X <- sapply(X, function(x) if(is.null(x)) {return(NA)} else (return(x)))
    stopifnot(length(dict)==length(X))
    i <- match(value.a, X)
    # Use the index to return the value for the sublist element named label.out
    value.b <- (dict[i][[1]][[label.out]])
    # Return NA instead of NULL else cannot be assigned to a vector
    if (is.null(value.b)) {
        return(NA)
    } else {
        return(value.b)
    }
}
